// Code generated by protoc-gen-go-lite. DO NOT EDIT.
// protoc-gen-go-lite version: v0.12.0
// source: github.com/aperturerobotics/bifrost/envelope/envelope.proto

package envelope

import (
	base64 "encoding/base64"
	fmt "fmt"
	io "io"
	slices "slices"
	strconv "strconv"
	strings "strings"

	protobuf_go_lite "github.com/aperturerobotics/protobuf-go-lite"
	json "github.com/aperturerobotics/protobuf-go-lite/json"
)

// Envelope contains an encrypted message unlockable via secret sharing.
//
// The message is encrypted with a key derived from a Ristretto255 scalar.
// The scalar is split into shares distributed across Grants.
// At least threshold+1 shares are needed to reconstruct the scalar.
type Envelope struct {
	unknownFields []byte
	// EnvelopeId is the unique identifier of the envelope.
	// If empty when building, generated from hash of secret + context.
	EnvelopeId string `protobuf:"bytes,1,opt,name=envelope_id,json=envelopeId,proto3" json:"envelopeId,omitempty"`
	// ContextHash is the BLAKE3 hash of the context string.
	// Used to verify the envelope matches the expected application context.
	ContextHash []byte `protobuf:"bytes,2,opt,name=context_hash,json=contextHash,proto3" json:"contextHash,omitempty"`
	// Threshold is the CIRCL threshold parameter.
	// Recovery requires threshold+1 shares.
	// If zero, any single share suffices (no secret splitting).
	Threshold uint32 `protobuf:"varint,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// Ciphertext is the encrypted payload.
	// Encrypted with XChaCha20-Poly1305 using a key derived from the scalar.
	Ciphertext []byte `protobuf:"bytes,4,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
	// Grants is the list of encrypted share bundles.
	Grants []*EnvelopeGrant `protobuf:"bytes,5,rep,name=grants,proto3" json:"grants,omitempty"`
	// Keypairs is the list of public keys used to encrypt grants.
	Keypairs []*EnvelopeKeypair `protobuf:"bytes,6,rep,name=keypairs,proto3" json:"keypairs,omitempty"`
	// Contents is an optional plaintext description of what the envelope contains.
	// Application-specific; not used in the unlock process.
	Contents []byte `protobuf:"bytes,7,opt,name=contents,proto3" json:"contents,omitempty"`
}

func (x *Envelope) Reset() {
	*x = Envelope{}
}

func (*Envelope) ProtoMessage() {}

func (x *Envelope) GetEnvelopeId() string {
	if x != nil {
		return x.EnvelopeId
	}
	return ""
}

func (x *Envelope) GetContextHash() []byte {
	if x != nil {
		return x.ContextHash
	}
	return nil
}

func (x *Envelope) GetThreshold() uint32 {
	if x != nil {
		return x.Threshold
	}
	return 0
}

func (x *Envelope) GetCiphertext() []byte {
	if x != nil {
		return x.Ciphertext
	}
	return nil
}

func (x *Envelope) GetGrants() []*EnvelopeGrant {
	if x != nil {
		return x.Grants
	}
	return nil
}

func (x *Envelope) GetKeypairs() []*EnvelopeKeypair {
	if x != nil {
		return x.Keypairs
	}
	return nil
}

func (x *Envelope) GetContents() []byte {
	if x != nil {
		return x.Contents
	}
	return nil
}

// EnvelopeGrant is an encrypted bundle of shares.
// The grant ciphertext contains a marshaled EnvelopeGrantInner.
// Encrypted to one or more keypairs in the Envelope keypairs list.
type EnvelopeGrant struct {
	unknownFields []byte
	// KeypairIndexes lists which keypairs can decrypt this grant.
	// Each value is an index into the Envelope.keypairs list.
	KeypairIndexes []uint32 `protobuf:"varint,1,rep,packed,name=keypair_indexes,json=keypairIndexes,proto3" json:"keypairIndexes,omitempty"`
	// Ciphertexts contains the encrypted EnvelopeGrantInner.
	// One ciphertext per keypair index, in the same order.
	// Each encrypted with peer.EncryptToPubKey to the corresponding keypair.
	Ciphertexts [][]byte `protobuf:"bytes,2,rep,name=ciphertexts,proto3" json:"ciphertexts,omitempty"`
}

func (x *EnvelopeGrant) Reset() {
	*x = EnvelopeGrant{}
}

func (*EnvelopeGrant) ProtoMessage() {}

func (x *EnvelopeGrant) GetKeypairIndexes() []uint32 {
	if x != nil {
		return x.KeypairIndexes
	}
	return nil
}

func (x *EnvelopeGrant) GetCiphertexts() [][]byte {
	if x != nil {
		return x.Ciphertexts
	}
	return nil
}

// EnvelopeGrantInner is the decrypted contents of a grant.
type EnvelopeGrantInner struct {
	unknownFields []byte
	// Shares is the list of Shamir shares in this grant.
	Shares []*EnvelopeShare `protobuf:"bytes,1,rep,name=shares,proto3" json:"shares,omitempty"`
}

func (x *EnvelopeGrantInner) Reset() {
	*x = EnvelopeGrantInner{}
}

func (*EnvelopeGrantInner) ProtoMessage() {}

func (x *EnvelopeGrantInner) GetShares() []*EnvelopeShare {
	if x != nil {
		return x.Shares
	}
	return nil
}

// EnvelopeShare is a single Shamir share (Ristretto255 scalar pair).
type EnvelopeShare struct {
	unknownFields []byte
	// Id is the share identifier (marshaled Ristretto255 scalar, 32 bytes).
	Id []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Value is the share value (marshaled Ristretto255 scalar, 32 bytes).
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *EnvelopeShare) Reset() {
	*x = EnvelopeShare{}
}

func (*EnvelopeShare) ProtoMessage() {}

func (x *EnvelopeShare) GetId() []byte {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *EnvelopeShare) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

// EnvelopeKeypair is a public key entry in the envelope.
type EnvelopeKeypair struct {
	unknownFields []byte
	// PubKey is the marshaled public key (libp2p crypto format).
	PubKey []byte `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3" json:"pubKey,omitempty"`
	// AuthMethodId is an optional identifier for the auth method.
	// Application-specific hint for how to derive the private key.
	AuthMethodId string `protobuf:"bytes,2,opt,name=auth_method_id,json=authMethodId,proto3" json:"authMethodId,omitempty"`
	// AuthMethodParams is optional parameters for the auth method.
	AuthMethodParams []byte `protobuf:"bytes,3,opt,name=auth_method_params,json=authMethodParams,proto3" json:"authMethodParams,omitempty"`
}

func (x *EnvelopeKeypair) Reset() {
	*x = EnvelopeKeypair{}
}

func (*EnvelopeKeypair) ProtoMessage() {}

func (x *EnvelopeKeypair) GetPubKey() []byte {
	if x != nil {
		return x.PubKey
	}
	return nil
}

func (x *EnvelopeKeypair) GetAuthMethodId() string {
	if x != nil {
		return x.AuthMethodId
	}
	return ""
}

func (x *EnvelopeKeypair) GetAuthMethodParams() []byte {
	if x != nil {
		return x.AuthMethodParams
	}
	return nil
}

// EnvelopeConfig is the configuration for building an envelope.
type EnvelopeConfig struct {
	unknownFields []byte
	// EnvelopeId is the unique identifier. If empty, auto-generated.
	EnvelopeId string `protobuf:"bytes,1,opt,name=envelope_id,json=envelopeId,proto3" json:"envelopeId,omitempty"`
	// Threshold is the CIRCL threshold parameter (need threshold+1 shares).
	// If zero, any single share suffices.
	Threshold uint32 `protobuf:"varint,2,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// TotalShares is the total number of shares to create.
	// If zero, defaults to sum of shares across all grant configs.
	TotalShares uint32 `protobuf:"varint,3,opt,name=total_shares,json=totalShares,proto3" json:"totalShares,omitempty"`
	// GrantConfigs defines how shares are distributed across grants.
	GrantConfigs []*EnvelopeGrantConfig `protobuf:"bytes,4,rep,name=grant_configs,json=grantConfigs,proto3" json:"grantConfigs,omitempty"`
}

func (x *EnvelopeConfig) Reset() {
	*x = EnvelopeConfig{}
}

func (*EnvelopeConfig) ProtoMessage() {}

func (x *EnvelopeConfig) GetEnvelopeId() string {
	if x != nil {
		return x.EnvelopeId
	}
	return ""
}

func (x *EnvelopeConfig) GetThreshold() uint32 {
	if x != nil {
		return x.Threshold
	}
	return 0
}

func (x *EnvelopeConfig) GetTotalShares() uint32 {
	if x != nil {
		return x.TotalShares
	}
	return 0
}

func (x *EnvelopeConfig) GetGrantConfigs() []*EnvelopeGrantConfig {
	if x != nil {
		return x.GrantConfigs
	}
	return nil
}

// EnvelopeGrantConfig configures a single grant in the envelope.
type EnvelopeGrantConfig struct {
	unknownFields []byte
	// ShareCount is the number of shares to include in this grant.
	// If zero, defaults to 1.
	ShareCount uint32 `protobuf:"varint,1,opt,name=share_count,json=shareCount,proto3" json:"shareCount,omitempty"`
	// KeypairIndexes lists which keypairs can decrypt this grant.
	// Indexes into the keypairs list provided to BuildEnvelope.
	KeypairIndexes []uint32 `protobuf:"varint,2,rep,packed,name=keypair_indexes,json=keypairIndexes,proto3" json:"keypairIndexes,omitempty"`
}

func (x *EnvelopeGrantConfig) Reset() {
	*x = EnvelopeGrantConfig{}
}

func (*EnvelopeGrantConfig) ProtoMessage() {}

func (x *EnvelopeGrantConfig) GetShareCount() uint32 {
	if x != nil {
		return x.ShareCount
	}
	return 0
}

func (x *EnvelopeGrantConfig) GetKeypairIndexes() []uint32 {
	if x != nil {
		return x.KeypairIndexes
	}
	return nil
}

// EnvelopeUnlockResult is the result of attempting to unlock an envelope.
type EnvelopeUnlockResult struct {
	unknownFields []byte
	// Success indicates whether the envelope was fully unlocked.
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// SharesAvailable is the number of shares recovered from grants.
	SharesAvailable uint32 `protobuf:"varint,2,opt,name=shares_available,json=sharesAvailable,proto3" json:"sharesAvailable,omitempty"`
	// SharesNeeded is the number of shares needed (threshold+1).
	SharesNeeded uint32 `protobuf:"varint,3,opt,name=shares_needed,json=sharesNeeded,proto3" json:"sharesNeeded,omitempty"`
	// UnlockedGrantIndexes lists which grants were successfully decrypted.
	UnlockedGrantIndexes []uint32 `protobuf:"varint,4,rep,packed,name=unlocked_grant_indexes,json=unlockedGrantIndexes,proto3" json:"unlockedGrantIndexes,omitempty"`
}

func (x *EnvelopeUnlockResult) Reset() {
	*x = EnvelopeUnlockResult{}
}

func (*EnvelopeUnlockResult) ProtoMessage() {}

func (x *EnvelopeUnlockResult) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *EnvelopeUnlockResult) GetSharesAvailable() uint32 {
	if x != nil {
		return x.SharesAvailable
	}
	return 0
}

func (x *EnvelopeUnlockResult) GetSharesNeeded() uint32 {
	if x != nil {
		return x.SharesNeeded
	}
	return 0
}

func (x *EnvelopeUnlockResult) GetUnlockedGrantIndexes() []uint32 {
	if x != nil {
		return x.UnlockedGrantIndexes
	}
	return nil
}

func (m *Envelope) CloneVT() *Envelope {
	if m == nil {
		return (*Envelope)(nil)
	}
	r := new(Envelope)
	r.EnvelopeId = m.EnvelopeId
	r.Threshold = m.Threshold
	if rhs := m.ContextHash; rhs != nil {
		r.ContextHash = slices.Clone(rhs)
	}
	if rhs := m.Ciphertext; rhs != nil {
		r.Ciphertext = slices.Clone(rhs)
	}
	if rhs := m.Grants; rhs != nil {
		r.Grants = make([]*EnvelopeGrant, len(rhs))
		for k, v := range rhs {
			r.Grants[k] = v.CloneVT()
		}
	}
	if rhs := m.Keypairs; rhs != nil {
		r.Keypairs = make([]*EnvelopeKeypair, len(rhs))
		for k, v := range rhs {
			r.Keypairs[k] = v.CloneVT()
		}
	}
	if rhs := m.Contents; rhs != nil {
		r.Contents = slices.Clone(rhs)
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = slices.Clone(m.unknownFields)
	}
	return r
}

func (m *Envelope) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *EnvelopeGrant) CloneVT() *EnvelopeGrant {
	if m == nil {
		return (*EnvelopeGrant)(nil)
	}
	r := new(EnvelopeGrant)
	if rhs := m.KeypairIndexes; rhs != nil {
		r.KeypairIndexes = slices.Clone(rhs)
	}
	if rhs := m.Ciphertexts; rhs != nil {
		r.Ciphertexts = make([][]byte, len(rhs))
		for k, v := range rhs {
			r.Ciphertexts[k] = slices.Clone(v)
		}
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = slices.Clone(m.unknownFields)
	}
	return r
}

func (m *EnvelopeGrant) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *EnvelopeGrantInner) CloneVT() *EnvelopeGrantInner {
	if m == nil {
		return (*EnvelopeGrantInner)(nil)
	}
	r := new(EnvelopeGrantInner)
	if rhs := m.Shares; rhs != nil {
		r.Shares = make([]*EnvelopeShare, len(rhs))
		for k, v := range rhs {
			r.Shares[k] = v.CloneVT()
		}
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = slices.Clone(m.unknownFields)
	}
	return r
}

func (m *EnvelopeGrantInner) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *EnvelopeShare) CloneVT() *EnvelopeShare {
	if m == nil {
		return (*EnvelopeShare)(nil)
	}
	r := new(EnvelopeShare)
	if rhs := m.Id; rhs != nil {
		r.Id = slices.Clone(rhs)
	}
	if rhs := m.Value; rhs != nil {
		r.Value = slices.Clone(rhs)
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = slices.Clone(m.unknownFields)
	}
	return r
}

func (m *EnvelopeShare) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *EnvelopeKeypair) CloneVT() *EnvelopeKeypair {
	if m == nil {
		return (*EnvelopeKeypair)(nil)
	}
	r := new(EnvelopeKeypair)
	r.AuthMethodId = m.AuthMethodId
	if rhs := m.PubKey; rhs != nil {
		r.PubKey = slices.Clone(rhs)
	}
	if rhs := m.AuthMethodParams; rhs != nil {
		r.AuthMethodParams = slices.Clone(rhs)
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = slices.Clone(m.unknownFields)
	}
	return r
}

func (m *EnvelopeKeypair) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *EnvelopeConfig) CloneVT() *EnvelopeConfig {
	if m == nil {
		return (*EnvelopeConfig)(nil)
	}
	r := new(EnvelopeConfig)
	r.EnvelopeId = m.EnvelopeId
	r.Threshold = m.Threshold
	r.TotalShares = m.TotalShares
	if rhs := m.GrantConfigs; rhs != nil {
		r.GrantConfigs = make([]*EnvelopeGrantConfig, len(rhs))
		for k, v := range rhs {
			r.GrantConfigs[k] = v.CloneVT()
		}
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = slices.Clone(m.unknownFields)
	}
	return r
}

func (m *EnvelopeConfig) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *EnvelopeGrantConfig) CloneVT() *EnvelopeGrantConfig {
	if m == nil {
		return (*EnvelopeGrantConfig)(nil)
	}
	r := new(EnvelopeGrantConfig)
	r.ShareCount = m.ShareCount
	if rhs := m.KeypairIndexes; rhs != nil {
		r.KeypairIndexes = slices.Clone(rhs)
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = slices.Clone(m.unknownFields)
	}
	return r
}

func (m *EnvelopeGrantConfig) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (m *EnvelopeUnlockResult) CloneVT() *EnvelopeUnlockResult {
	if m == nil {
		return (*EnvelopeUnlockResult)(nil)
	}
	r := new(EnvelopeUnlockResult)
	r.Success = m.Success
	r.SharesAvailable = m.SharesAvailable
	r.SharesNeeded = m.SharesNeeded
	if rhs := m.UnlockedGrantIndexes; rhs != nil {
		r.UnlockedGrantIndexes = slices.Clone(rhs)
	}
	if len(m.unknownFields) > 0 {
		r.unknownFields = slices.Clone(m.unknownFields)
	}
	return r
}

func (m *EnvelopeUnlockResult) CloneMessageVT() protobuf_go_lite.CloneMessage {
	return m.CloneVT()
}

func (this *Envelope) EqualVT(that *Envelope) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.EnvelopeId != that.EnvelopeId {
		return false
	}
	if string(this.ContextHash) != string(that.ContextHash) {
		return false
	}
	if this.Threshold != that.Threshold {
		return false
	}
	if string(this.Ciphertext) != string(that.Ciphertext) {
		return false
	}
	if len(this.Grants) != len(that.Grants) {
		return false
	}
	for i, vx := range this.Grants {
		vy := that.Grants[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &EnvelopeGrant{}
			}
			if q == nil {
				q = &EnvelopeGrant{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if len(this.Keypairs) != len(that.Keypairs) {
		return false
	}
	for i, vx := range this.Keypairs {
		vy := that.Keypairs[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &EnvelopeKeypair{}
			}
			if q == nil {
				q = &EnvelopeKeypair{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	if string(this.Contents) != string(that.Contents) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *Envelope) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*Envelope)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

func (this *EnvelopeGrant) EqualVT(that *EnvelopeGrant) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.KeypairIndexes) != len(that.KeypairIndexes) {
		return false
	}
	for i, vx := range this.KeypairIndexes {
		vy := that.KeypairIndexes[i]
		if vx != vy {
			return false
		}
	}
	if len(this.Ciphertexts) != len(that.Ciphertexts) {
		return false
	}
	for i, vx := range this.Ciphertexts {
		vy := that.Ciphertexts[i]
		if string(vx) != string(vy) {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *EnvelopeGrant) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*EnvelopeGrant)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

func (this *EnvelopeGrantInner) EqualVT(that *EnvelopeGrantInner) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if len(this.Shares) != len(that.Shares) {
		return false
	}
	for i, vx := range this.Shares {
		vy := that.Shares[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &EnvelopeShare{}
			}
			if q == nil {
				q = &EnvelopeShare{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *EnvelopeGrantInner) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*EnvelopeGrantInner)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

func (this *EnvelopeShare) EqualVT(that *EnvelopeShare) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if string(this.Id) != string(that.Id) {
		return false
	}
	if string(this.Value) != string(that.Value) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *EnvelopeShare) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*EnvelopeShare)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

func (this *EnvelopeKeypair) EqualVT(that *EnvelopeKeypair) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if string(this.PubKey) != string(that.PubKey) {
		return false
	}
	if this.AuthMethodId != that.AuthMethodId {
		return false
	}
	if string(this.AuthMethodParams) != string(that.AuthMethodParams) {
		return false
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *EnvelopeKeypair) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*EnvelopeKeypair)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

func (this *EnvelopeConfig) EqualVT(that *EnvelopeConfig) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.EnvelopeId != that.EnvelopeId {
		return false
	}
	if this.Threshold != that.Threshold {
		return false
	}
	if this.TotalShares != that.TotalShares {
		return false
	}
	if len(this.GrantConfigs) != len(that.GrantConfigs) {
		return false
	}
	for i, vx := range this.GrantConfigs {
		vy := that.GrantConfigs[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &EnvelopeGrantConfig{}
			}
			if q == nil {
				q = &EnvelopeGrantConfig{}
			}
			if !p.EqualVT(q) {
				return false
			}
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *EnvelopeConfig) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*EnvelopeConfig)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

func (this *EnvelopeGrantConfig) EqualVT(that *EnvelopeGrantConfig) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.ShareCount != that.ShareCount {
		return false
	}
	if len(this.KeypairIndexes) != len(that.KeypairIndexes) {
		return false
	}
	for i, vx := range this.KeypairIndexes {
		vy := that.KeypairIndexes[i]
		if vx != vy {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *EnvelopeGrantConfig) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*EnvelopeGrantConfig)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

func (this *EnvelopeUnlockResult) EqualVT(that *EnvelopeUnlockResult) bool {
	if this == that {
		return true
	} else if this == nil || that == nil {
		return false
	}
	if this.Success != that.Success {
		return false
	}
	if this.SharesAvailable != that.SharesAvailable {
		return false
	}
	if this.SharesNeeded != that.SharesNeeded {
		return false
	}
	if len(this.UnlockedGrantIndexes) != len(that.UnlockedGrantIndexes) {
		return false
	}
	for i, vx := range this.UnlockedGrantIndexes {
		vy := that.UnlockedGrantIndexes[i]
		if vx != vy {
			return false
		}
	}
	return string(this.unknownFields) == string(that.unknownFields)
}

func (this *EnvelopeUnlockResult) EqualMessageVT(thatMsg any) bool {
	that, ok := thatMsg.(*EnvelopeUnlockResult)
	if !ok {
		return false
	}
	return this.EqualVT(that)
}

// MarshalProtoJSON marshals the Envelope message to JSON.
func (x *Envelope) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.EnvelopeId != "" || s.HasField("envelopeId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("envelopeId")
		s.WriteString(x.EnvelopeId)
	}
	if len(x.ContextHash) > 0 || s.HasField("contextHash") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("contextHash")
		s.WriteBytes(x.ContextHash)
	}
	if x.Threshold != 0 || s.HasField("threshold") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("threshold")
		s.WriteUint32(x.Threshold)
	}
	if len(x.Ciphertext) > 0 || s.HasField("ciphertext") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("ciphertext")
		s.WriteBytes(x.Ciphertext)
	}
	if len(x.Grants) > 0 || s.HasField("grants") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("grants")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Grants {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("grants"))
		}
		s.WriteArrayEnd()
	}
	if len(x.Keypairs) > 0 || s.HasField("keypairs") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keypairs")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Keypairs {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("keypairs"))
		}
		s.WriteArrayEnd()
	}
	if len(x.Contents) > 0 || s.HasField("contents") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("contents")
		s.WriteBytes(x.Contents)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the Envelope to JSON.
func (x *Envelope) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the Envelope message from JSON.
func (x *Envelope) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "envelope_id", "envelopeId":
			s.AddField("envelope_id")
			x.EnvelopeId = s.ReadString()
		case "context_hash", "contextHash":
			s.AddField("context_hash")
			x.ContextHash = s.ReadBytes()
		case "threshold":
			s.AddField("threshold")
			x.Threshold = s.ReadUint32()
		case "ciphertext":
			s.AddField("ciphertext")
			x.Ciphertext = s.ReadBytes()
		case "grants":
			s.AddField("grants")
			if s.ReadNil() {
				x.Grants = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Grants = append(x.Grants, nil)
					return
				}
				v := &EnvelopeGrant{}
				v.UnmarshalProtoJSON(s.WithField("grants", false))
				if s.Err() != nil {
					return
				}
				x.Grants = append(x.Grants, v)
			})
		case "keypairs":
			s.AddField("keypairs")
			if s.ReadNil() {
				x.Keypairs = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Keypairs = append(x.Keypairs, nil)
					return
				}
				v := &EnvelopeKeypair{}
				v.UnmarshalProtoJSON(s.WithField("keypairs", false))
				if s.Err() != nil {
					return
				}
				x.Keypairs = append(x.Keypairs, v)
			})
		case "contents":
			s.AddField("contents")
			x.Contents = s.ReadBytes()
		}
	})
}

// UnmarshalJSON unmarshals the Envelope from JSON.
func (x *Envelope) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the EnvelopeGrant message to JSON.
func (x *EnvelopeGrant) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.KeypairIndexes) > 0 || s.HasField("keypairIndexes") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keypairIndexes")
		s.WriteUint32Array(x.KeypairIndexes)
	}
	if len(x.Ciphertexts) > 0 || s.HasField("ciphertexts") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("ciphertexts")
		s.WriteBytesArray(x.Ciphertexts)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the EnvelopeGrant to JSON.
func (x *EnvelopeGrant) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the EnvelopeGrant message from JSON.
func (x *EnvelopeGrant) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "keypair_indexes", "keypairIndexes":
			s.AddField("keypair_indexes")
			if s.ReadNil() {
				x.KeypairIndexes = nil
				return
			}
			x.KeypairIndexes = s.ReadUint32Array()
		case "ciphertexts":
			s.AddField("ciphertexts")
			if s.ReadNil() {
				x.Ciphertexts = nil
				return
			}
			x.Ciphertexts = s.ReadBytesArray()
		}
	})
}

// UnmarshalJSON unmarshals the EnvelopeGrant from JSON.
func (x *EnvelopeGrant) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the EnvelopeGrantInner message to JSON.
func (x *EnvelopeGrantInner) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.Shares) > 0 || s.HasField("shares") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shares")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Shares {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("shares"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the EnvelopeGrantInner to JSON.
func (x *EnvelopeGrantInner) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the EnvelopeGrantInner message from JSON.
func (x *EnvelopeGrantInner) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "shares":
			s.AddField("shares")
			if s.ReadNil() {
				x.Shares = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Shares = append(x.Shares, nil)
					return
				}
				v := &EnvelopeShare{}
				v.UnmarshalProtoJSON(s.WithField("shares", false))
				if s.Err() != nil {
					return
				}
				x.Shares = append(x.Shares, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the EnvelopeGrantInner from JSON.
func (x *EnvelopeGrantInner) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the EnvelopeShare message to JSON.
func (x *EnvelopeShare) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.Id) > 0 || s.HasField("id") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("id")
		s.WriteBytes(x.Id)
	}
	if len(x.Value) > 0 || s.HasField("value") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("value")
		s.WriteBytes(x.Value)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the EnvelopeShare to JSON.
func (x *EnvelopeShare) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the EnvelopeShare message from JSON.
func (x *EnvelopeShare) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "id":
			s.AddField("id")
			x.Id = s.ReadBytes()
		case "value":
			s.AddField("value")
			x.Value = s.ReadBytes()
		}
	})
}

// UnmarshalJSON unmarshals the EnvelopeShare from JSON.
func (x *EnvelopeShare) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the EnvelopeKeypair message to JSON.
func (x *EnvelopeKeypair) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.PubKey) > 0 || s.HasField("pubKey") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("pubKey")
		s.WriteBytes(x.PubKey)
	}
	if x.AuthMethodId != "" || s.HasField("authMethodId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("authMethodId")
		s.WriteString(x.AuthMethodId)
	}
	if len(x.AuthMethodParams) > 0 || s.HasField("authMethodParams") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("authMethodParams")
		s.WriteBytes(x.AuthMethodParams)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the EnvelopeKeypair to JSON.
func (x *EnvelopeKeypair) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the EnvelopeKeypair message from JSON.
func (x *EnvelopeKeypair) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "pub_key", "pubKey":
			s.AddField("pub_key")
			x.PubKey = s.ReadBytes()
		case "auth_method_id", "authMethodId":
			s.AddField("auth_method_id")
			x.AuthMethodId = s.ReadString()
		case "auth_method_params", "authMethodParams":
			s.AddField("auth_method_params")
			x.AuthMethodParams = s.ReadBytes()
		}
	})
}

// UnmarshalJSON unmarshals the EnvelopeKeypair from JSON.
func (x *EnvelopeKeypair) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the EnvelopeConfig message to JSON.
func (x *EnvelopeConfig) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.EnvelopeId != "" || s.HasField("envelopeId") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("envelopeId")
		s.WriteString(x.EnvelopeId)
	}
	if x.Threshold != 0 || s.HasField("threshold") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("threshold")
		s.WriteUint32(x.Threshold)
	}
	if x.TotalShares != 0 || s.HasField("totalShares") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("totalShares")
		s.WriteUint32(x.TotalShares)
	}
	if len(x.GrantConfigs) > 0 || s.HasField("grantConfigs") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("grantConfigs")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.GrantConfigs {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("grantConfigs"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the EnvelopeConfig to JSON.
func (x *EnvelopeConfig) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the EnvelopeConfig message from JSON.
func (x *EnvelopeConfig) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "envelope_id", "envelopeId":
			s.AddField("envelope_id")
			x.EnvelopeId = s.ReadString()
		case "threshold":
			s.AddField("threshold")
			x.Threshold = s.ReadUint32()
		case "total_shares", "totalShares":
			s.AddField("total_shares")
			x.TotalShares = s.ReadUint32()
		case "grant_configs", "grantConfigs":
			s.AddField("grant_configs")
			if s.ReadNil() {
				x.GrantConfigs = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.GrantConfigs = append(x.GrantConfigs, nil)
					return
				}
				v := &EnvelopeGrantConfig{}
				v.UnmarshalProtoJSON(s.WithField("grant_configs", false))
				if s.Err() != nil {
					return
				}
				x.GrantConfigs = append(x.GrantConfigs, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the EnvelopeConfig from JSON.
func (x *EnvelopeConfig) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the EnvelopeGrantConfig message to JSON.
func (x *EnvelopeGrantConfig) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.ShareCount != 0 || s.HasField("shareCount") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("shareCount")
		s.WriteUint32(x.ShareCount)
	}
	if len(x.KeypairIndexes) > 0 || s.HasField("keypairIndexes") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("keypairIndexes")
		s.WriteUint32Array(x.KeypairIndexes)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the EnvelopeGrantConfig to JSON.
func (x *EnvelopeGrantConfig) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the EnvelopeGrantConfig message from JSON.
func (x *EnvelopeGrantConfig) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "share_count", "shareCount":
			s.AddField("share_count")
			x.ShareCount = s.ReadUint32()
		case "keypair_indexes", "keypairIndexes":
			s.AddField("keypair_indexes")
			if s.ReadNil() {
				x.KeypairIndexes = nil
				return
			}
			x.KeypairIndexes = s.ReadUint32Array()
		}
	})
}

// UnmarshalJSON unmarshals the EnvelopeGrantConfig from JSON.
func (x *EnvelopeGrantConfig) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the EnvelopeUnlockResult message to JSON.
func (x *EnvelopeUnlockResult) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Success || s.HasField("success") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("success")
		s.WriteBool(x.Success)
	}
	if x.SharesAvailable != 0 || s.HasField("sharesAvailable") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("sharesAvailable")
		s.WriteUint32(x.SharesAvailable)
	}
	if x.SharesNeeded != 0 || s.HasField("sharesNeeded") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("sharesNeeded")
		s.WriteUint32(x.SharesNeeded)
	}
	if len(x.UnlockedGrantIndexes) > 0 || s.HasField("unlockedGrantIndexes") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("unlockedGrantIndexes")
		s.WriteUint32Array(x.UnlockedGrantIndexes)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the EnvelopeUnlockResult to JSON.
func (x *EnvelopeUnlockResult) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the EnvelopeUnlockResult message from JSON.
func (x *EnvelopeUnlockResult) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "success":
			s.AddField("success")
			x.Success = s.ReadBool()
		case "shares_available", "sharesAvailable":
			s.AddField("shares_available")
			x.SharesAvailable = s.ReadUint32()
		case "shares_needed", "sharesNeeded":
			s.AddField("shares_needed")
			x.SharesNeeded = s.ReadUint32()
		case "unlocked_grant_indexes", "unlockedGrantIndexes":
			s.AddField("unlocked_grant_indexes")
			if s.ReadNil() {
				x.UnlockedGrantIndexes = nil
				return
			}
			x.UnlockedGrantIndexes = s.ReadUint32Array()
		}
	})
}

// UnmarshalJSON unmarshals the EnvelopeUnlockResult from JSON.
func (x *EnvelopeUnlockResult) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

func (m *Envelope) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Envelope) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *Envelope) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Contents) > 0 {
		i -= len(m.Contents)
		copy(dAtA[i:], m.Contents)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Contents)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Keypairs) > 0 {
		for iNdEx := len(m.Keypairs) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Keypairs[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Grants) > 0 {
		for iNdEx := len(m.Grants) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Grants[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Ciphertext) > 0 {
		i -= len(m.Ciphertext)
		copy(dAtA[i:], m.Ciphertext)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Ciphertext)))
		i--
		dAtA[i] = 0x22
	}
	if m.Threshold != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ContextHash) > 0 {
		i -= len(m.ContextHash)
		copy(dAtA[i:], m.ContextHash)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.ContextHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EnvelopeId) > 0 {
		i -= len(m.EnvelopeId)
		copy(dAtA[i:], m.EnvelopeId)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.EnvelopeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnvelopeGrant) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvelopeGrant) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *EnvelopeGrant) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Ciphertexts) > 0 {
		for iNdEx := len(m.Ciphertexts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ciphertexts[iNdEx])
			copy(dAtA[i:], m.Ciphertexts[iNdEx])
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Ciphertexts[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.KeypairIndexes) > 0 {
		var pksize2 int
		for _, num := range m.KeypairIndexes {
			pksize2 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize2
		j1 := i
		for _, num := range m.KeypairIndexes {
			for num >= 1<<7 {
				dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA[j1] = uint8(num)
			j1++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize2))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnvelopeGrantInner) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvelopeGrantInner) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *EnvelopeGrantInner) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Shares) > 0 {
		for iNdEx := len(m.Shares) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.Shares[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EnvelopeShare) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvelopeShare) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *EnvelopeShare) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnvelopeKeypair) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvelopeKeypair) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *EnvelopeKeypair) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.AuthMethodParams) > 0 {
		i -= len(m.AuthMethodParams)
		copy(dAtA[i:], m.AuthMethodParams)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.AuthMethodParams)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AuthMethodId) > 0 {
		i -= len(m.AuthMethodId)
		copy(dAtA[i:], m.AuthMethodId)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.AuthMethodId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnvelopeConfig) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvelopeConfig) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *EnvelopeConfig) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.GrantConfigs) > 0 {
		for iNdEx := len(m.GrantConfigs) - 1; iNdEx >= 0; iNdEx-- {
			size, err := m.GrantConfigs[iNdEx].MarshalToSizedBufferVT(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.TotalShares != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.TotalShares))
		i--
		dAtA[i] = 0x18
	}
	if m.Threshold != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x10
	}
	if len(m.EnvelopeId) > 0 {
		i -= len(m.EnvelopeId)
		copy(dAtA[i:], m.EnvelopeId)
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(len(m.EnvelopeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EnvelopeGrantConfig) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvelopeGrantConfig) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *EnvelopeGrantConfig) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.KeypairIndexes) > 0 {
		var pksize2 int
		for _, num := range m.KeypairIndexes {
			pksize2 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize2
		j1 := i
		for _, num := range m.KeypairIndexes {
			for num >= 1<<7 {
				dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA[j1] = uint8(num)
			j1++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize2))
		i--
		dAtA[i] = 0x12
	}
	if m.ShareCount != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.ShareCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EnvelopeUnlockResult) MarshalVT() (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := m.SizeVT()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBufferVT(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvelopeUnlockResult) MarshalToVT(dAtA []byte) (int, error) {
	size := m.SizeVT()
	return m.MarshalToSizedBufferVT(dAtA[:size])
}

func (m *EnvelopeUnlockResult) MarshalToSizedBufferVT(dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.unknownFields != nil {
		i -= len(m.unknownFields)
		copy(dAtA[i:], m.unknownFields)
	}
	if len(m.UnlockedGrantIndexes) > 0 {
		var pksize2 int
		for _, num := range m.UnlockedGrantIndexes {
			pksize2 += protobuf_go_lite.SizeOfVarint(uint64(num))
		}
		i -= pksize2
		j1 := i
		for _, num := range m.UnlockedGrantIndexes {
			for num >= 1<<7 {
				dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA[j1] = uint8(num)
			j1++
		}
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(pksize2))
		i--
		dAtA[i] = 0x22
	}
	if m.SharesNeeded != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.SharesNeeded))
		i--
		dAtA[i] = 0x18
	}
	if m.SharesAvailable != 0 {
		i = protobuf_go_lite.EncodeVarint(dAtA, i, uint64(m.SharesAvailable))
		i--
		dAtA[i] = 0x10
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Envelope) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EnvelopeId)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.ContextHash)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Threshold != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Threshold))
	}
	l = len(m.Ciphertext)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if len(m.Grants) > 0 {
		for _, e := range m.Grants {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	if len(m.Keypairs) > 0 {
		for _, e := range m.Keypairs {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	l = len(m.Contents)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *EnvelopeGrant) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.KeypairIndexes) > 0 {
		l = 0
		for _, e := range m.KeypairIndexes {
			l += protobuf_go_lite.SizeOfVarint(uint64(e))
		}
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(l)) + l
	}
	if len(m.Ciphertexts) > 0 {
		for _, b := range m.Ciphertexts {
			l = len(b)
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *EnvelopeGrantInner) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Shares) > 0 {
		for _, e := range m.Shares {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *EnvelopeShare) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *EnvelopeKeypair) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.AuthMethodId)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	l = len(m.AuthMethodParams)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	n += len(m.unknownFields)
	return n
}

func (m *EnvelopeConfig) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EnvelopeId)
	if l > 0 {
		n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
	}
	if m.Threshold != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.Threshold))
	}
	if m.TotalShares != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.TotalShares))
	}
	if len(m.GrantConfigs) > 0 {
		for _, e := range m.GrantConfigs {
			l = e.SizeVT()
			n += 1 + l + protobuf_go_lite.SizeOfVarint(uint64(l))
		}
	}
	n += len(m.unknownFields)
	return n
}

func (m *EnvelopeGrantConfig) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShareCount != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.ShareCount))
	}
	if len(m.KeypairIndexes) > 0 {
		l = 0
		for _, e := range m.KeypairIndexes {
			l += protobuf_go_lite.SizeOfVarint(uint64(e))
		}
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(l)) + l
	}
	n += len(m.unknownFields)
	return n
}

func (m *EnvelopeUnlockResult) SizeVT() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.SharesAvailable != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.SharesAvailable))
	}
	if m.SharesNeeded != 0 {
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(m.SharesNeeded))
	}
	if len(m.UnlockedGrantIndexes) > 0 {
		l = 0
		for _, e := range m.UnlockedGrantIndexes {
			l += protobuf_go_lite.SizeOfVarint(uint64(e))
		}
		n += 1 + protobuf_go_lite.SizeOfVarint(uint64(l)) + l
	}
	n += len(m.unknownFields)
	return n
}

func (x *Envelope) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("Envelope {")
	if x.EnvelopeId != "" {
		if sb.Len() > 10 {
			sb.WriteString(" ")
		}
		sb.WriteString("envelope_id: ")
		sb.WriteString(strconv.Quote(x.EnvelopeId))
	}
	if x.ContextHash != nil {
		if sb.Len() > 10 {
			sb.WriteString(" ")
		}
		sb.WriteString("context_hash: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.ContextHash))
		sb.WriteString("\"")
	}
	if x.Threshold != 0 {
		if sb.Len() > 10 {
			sb.WriteString(" ")
		}
		sb.WriteString("threshold: ")
		sb.WriteString(strconv.FormatUint(uint64(x.Threshold), 10))
	}
	if x.Ciphertext != nil {
		if sb.Len() > 10 {
			sb.WriteString(" ")
		}
		sb.WriteString("ciphertext: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.Ciphertext))
		sb.WriteString("\"")
	}
	if len(x.Grants) > 0 {
		if sb.Len() > 10 {
			sb.WriteString(" ")
		}
		sb.WriteString("grants: [")
		for i, v := range x.Grants {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if len(x.Keypairs) > 0 {
		if sb.Len() > 10 {
			sb.WriteString(" ")
		}
		sb.WriteString("keypairs: [")
		for i, v := range x.Keypairs {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	if x.Contents != nil {
		if sb.Len() > 10 {
			sb.WriteString(" ")
		}
		sb.WriteString("contents: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.Contents))
		sb.WriteString("\"")
	}
	sb.WriteString("}")
	return sb.String()
}

func (x *Envelope) String() string {
	return x.MarshalProtoText()
}

func (x *EnvelopeGrant) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("EnvelopeGrant {")
	if len(x.KeypairIndexes) > 0 {
		if sb.Len() > 15 {
			sb.WriteString(" ")
		}
		sb.WriteString("keypair_indexes: [")
		for i, v := range x.KeypairIndexes {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.FormatUint(uint64(v), 10))
		}
		sb.WriteString("]")
	}
	if len(x.Ciphertexts) > 0 {
		if sb.Len() > 15 {
			sb.WriteString(" ")
		}
		sb.WriteString("ciphertexts: [")
		for i, v := range x.Ciphertexts {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString("\"")
			sb.WriteString(base64.StdEncoding.EncodeToString(v))
			sb.WriteString("\"")
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}

func (x *EnvelopeGrant) String() string {
	return x.MarshalProtoText()
}

func (x *EnvelopeGrantInner) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("EnvelopeGrantInner {")
	if len(x.Shares) > 0 {
		if sb.Len() > 20 {
			sb.WriteString(" ")
		}
		sb.WriteString("shares: [")
		for i, v := range x.Shares {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}

func (x *EnvelopeGrantInner) String() string {
	return x.MarshalProtoText()
}

func (x *EnvelopeShare) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("EnvelopeShare {")
	if x.Id != nil {
		if sb.Len() > 15 {
			sb.WriteString(" ")
		}
		sb.WriteString("id: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.Id))
		sb.WriteString("\"")
	}
	if x.Value != nil {
		if sb.Len() > 15 {
			sb.WriteString(" ")
		}
		sb.WriteString("value: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.Value))
		sb.WriteString("\"")
	}
	sb.WriteString("}")
	return sb.String()
}

func (x *EnvelopeShare) String() string {
	return x.MarshalProtoText()
}

func (x *EnvelopeKeypair) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("EnvelopeKeypair {")
	if x.PubKey != nil {
		if sb.Len() > 17 {
			sb.WriteString(" ")
		}
		sb.WriteString("pub_key: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.PubKey))
		sb.WriteString("\"")
	}
	if x.AuthMethodId != "" {
		if sb.Len() > 17 {
			sb.WriteString(" ")
		}
		sb.WriteString("auth_method_id: ")
		sb.WriteString(strconv.Quote(x.AuthMethodId))
	}
	if x.AuthMethodParams != nil {
		if sb.Len() > 17 {
			sb.WriteString(" ")
		}
		sb.WriteString("auth_method_params: ")
		sb.WriteString("\"")
		sb.WriteString(base64.StdEncoding.EncodeToString(x.AuthMethodParams))
		sb.WriteString("\"")
	}
	sb.WriteString("}")
	return sb.String()
}

func (x *EnvelopeKeypair) String() string {
	return x.MarshalProtoText()
}

func (x *EnvelopeConfig) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("EnvelopeConfig {")
	if x.EnvelopeId != "" {
		if sb.Len() > 16 {
			sb.WriteString(" ")
		}
		sb.WriteString("envelope_id: ")
		sb.WriteString(strconv.Quote(x.EnvelopeId))
	}
	if x.Threshold != 0 {
		if sb.Len() > 16 {
			sb.WriteString(" ")
		}
		sb.WriteString("threshold: ")
		sb.WriteString(strconv.FormatUint(uint64(x.Threshold), 10))
	}
	if x.TotalShares != 0 {
		if sb.Len() > 16 {
			sb.WriteString(" ")
		}
		sb.WriteString("total_shares: ")
		sb.WriteString(strconv.FormatUint(uint64(x.TotalShares), 10))
	}
	if len(x.GrantConfigs) > 0 {
		if sb.Len() > 16 {
			sb.WriteString(" ")
		}
		sb.WriteString("grant_configs: [")
		for i, v := range x.GrantConfigs {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(v.MarshalProtoText())
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}

func (x *EnvelopeConfig) String() string {
	return x.MarshalProtoText()
}

func (x *EnvelopeGrantConfig) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("EnvelopeGrantConfig {")
	if x.ShareCount != 0 {
		if sb.Len() > 21 {
			sb.WriteString(" ")
		}
		sb.WriteString("share_count: ")
		sb.WriteString(strconv.FormatUint(uint64(x.ShareCount), 10))
	}
	if len(x.KeypairIndexes) > 0 {
		if sb.Len() > 21 {
			sb.WriteString(" ")
		}
		sb.WriteString("keypair_indexes: [")
		for i, v := range x.KeypairIndexes {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.FormatUint(uint64(v), 10))
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}

func (x *EnvelopeGrantConfig) String() string {
	return x.MarshalProtoText()
}

func (x *EnvelopeUnlockResult) MarshalProtoText() string {
	var sb strings.Builder
	sb.WriteString("EnvelopeUnlockResult {")
	if x.Success != false {
		if sb.Len() > 22 {
			sb.WriteString(" ")
		}
		sb.WriteString("success: ")
		sb.WriteString(strconv.FormatBool(x.Success))
	}
	if x.SharesAvailable != 0 {
		if sb.Len() > 22 {
			sb.WriteString(" ")
		}
		sb.WriteString("shares_available: ")
		sb.WriteString(strconv.FormatUint(uint64(x.SharesAvailable), 10))
	}
	if x.SharesNeeded != 0 {
		if sb.Len() > 22 {
			sb.WriteString(" ")
		}
		sb.WriteString("shares_needed: ")
		sb.WriteString(strconv.FormatUint(uint64(x.SharesNeeded), 10))
	}
	if len(x.UnlockedGrantIndexes) > 0 {
		if sb.Len() > 22 {
			sb.WriteString(" ")
		}
		sb.WriteString("unlocked_grant_indexes: [")
		for i, v := range x.UnlockedGrantIndexes {
			if i > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(strconv.FormatUint(uint64(v), 10))
		}
		sb.WriteString("]")
	}
	sb.WriteString("}")
	return sb.String()
}

func (x *EnvelopeUnlockResult) String() string {
	return x.MarshalProtoText()
}

func (m *Envelope) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Envelope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Envelope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvelopeId", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvelopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextHash", wireType)
			}
			var byteLen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			byteLen = int(_v)
			if err != nil {
				return err
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContextHash = append(m.ContextHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ContextHash == nil {
				m.ContextHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			m.Threshold, iNdEx, err = protobuf_go_lite.DecodeVarintUint32(dAtA, iNdEx)
			if err != nil {
				return err
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphertext", wireType)
			}
			var byteLen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			byteLen = int(_v)
			if err != nil {
				return err
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphertext = append(m.Ciphertext[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphertext == nil {
				m.Ciphertext = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grants", wireType)
			}
			var msglen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			msglen = int(_v)
			if err != nil {
				return err
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grants = append(m.Grants, &EnvelopeGrant{})
			if err := m.Grants[len(m.Grants)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keypairs", wireType)
			}
			var msglen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			msglen = int(_v)
			if err != nil {
				return err
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keypairs = append(m.Keypairs, &EnvelopeKeypair{})
			if err := m.Keypairs[len(m.Keypairs)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contents", wireType)
			}
			var byteLen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			byteLen = int(_v)
			if err != nil {
				return err
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contents = append(m.Contents[:0], dAtA[iNdEx:postIndex]...)
			if m.Contents == nil {
				m.Contents = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *EnvelopeGrant) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvelopeGrant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvelopeGrant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				v, iNdEx, err = protobuf_go_lite.DecodeVarintUint32(dAtA, iNdEx)
				if err != nil {
					return err
				}
				m.KeypairIndexes = append(m.KeypairIndexes, v)
			} else if wireType == 2 {
				var packedLen int
				var _v uint64
				_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
				packedLen = int(_v)
				if err != nil {
					return err
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.KeypairIndexes) == 0 {
					m.KeypairIndexes = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					v, iNdEx, err = protobuf_go_lite.DecodeVarintUint32(dAtA, iNdEx)
					if err != nil {
						return err
					}
					m.KeypairIndexes = append(m.KeypairIndexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeypairIndexes", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphertexts", wireType)
			}
			var byteLen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			byteLen = int(_v)
			if err != nil {
				return err
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphertexts = append(m.Ciphertexts, make([]byte, postIndex-iNdEx))
			copy(m.Ciphertexts[len(m.Ciphertexts)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *EnvelopeGrantInner) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvelopeGrantInner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvelopeGrantInner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var msglen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			msglen = int(_v)
			if err != nil {
				return err
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shares = append(m.Shares, &EnvelopeShare{})
			if err := m.Shares[len(m.Shares)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *EnvelopeShare) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvelopeShare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvelopeShare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			byteLen = int(_v)
			if err != nil {
				return err
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			byteLen = int(_v)
			if err != nil {
				return err
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *EnvelopeKeypair) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvelopeKeypair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvelopeKeypair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			byteLen = int(_v)
			if err != nil {
				return err
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthMethodId", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthMethodId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthMethodParams", wireType)
			}
			var byteLen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			byteLen = int(_v)
			if err != nil {
				return err
			}
			if byteLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthMethodParams = append(m.AuthMethodParams[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthMethodParams == nil {
				m.AuthMethodParams = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *EnvelopeConfig) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvelopeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvelopeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvelopeId", wireType)
			}
			var stringLen uint64
			stringLen, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			if err != nil {
				return err
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvelopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			m.Threshold, iNdEx, err = protobuf_go_lite.DecodeVarintUint32(dAtA, iNdEx)
			if err != nil {
				return err
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalShares", wireType)
			}
			m.TotalShares = 0
			m.TotalShares, iNdEx, err = protobuf_go_lite.DecodeVarintUint32(dAtA, iNdEx)
			if err != nil {
				return err
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrantConfigs", wireType)
			}
			var msglen int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			msglen = int(_v)
			if err != nil {
				return err
			}
			if msglen < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GrantConfigs = append(m.GrantConfigs, &EnvelopeGrantConfig{})
			if err := m.GrantConfigs[len(m.GrantConfigs)-1].UnmarshalVT(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *EnvelopeGrantConfig) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvelopeGrantConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvelopeGrantConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareCount", wireType)
			}
			m.ShareCount = 0
			m.ShareCount, iNdEx, err = protobuf_go_lite.DecodeVarintUint32(dAtA, iNdEx)
			if err != nil {
				return err
			}
		case 2:
			if wireType == 0 {
				var v uint32
				v, iNdEx, err = protobuf_go_lite.DecodeVarintUint32(dAtA, iNdEx)
				if err != nil {
					return err
				}
				m.KeypairIndexes = append(m.KeypairIndexes, v)
			} else if wireType == 2 {
				var packedLen int
				var _v uint64
				_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
				packedLen = int(_v)
				if err != nil {
					return err
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.KeypairIndexes) == 0 {
					m.KeypairIndexes = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					v, iNdEx, err = protobuf_go_lite.DecodeVarintUint32(dAtA, iNdEx)
					if err != nil {
						return err
					}
					m.KeypairIndexes = append(m.KeypairIndexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeypairIndexes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

func (m *EnvelopeUnlockResult) UnmarshalVT(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	var err error
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		wire, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
		if err != nil {
			return err
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvelopeUnlockResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvelopeUnlockResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			var _v uint64
			_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
			v = int(_v)
			if err != nil {
				return err
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesAvailable", wireType)
			}
			m.SharesAvailable = 0
			m.SharesAvailable, iNdEx, err = protobuf_go_lite.DecodeVarintUint32(dAtA, iNdEx)
			if err != nil {
				return err
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharesNeeded", wireType)
			}
			m.SharesNeeded = 0
			m.SharesNeeded, iNdEx, err = protobuf_go_lite.DecodeVarintUint32(dAtA, iNdEx)
			if err != nil {
				return err
			}
		case 4:
			if wireType == 0 {
				var v uint32
				v, iNdEx, err = protobuf_go_lite.DecodeVarintUint32(dAtA, iNdEx)
				if err != nil {
					return err
				}
				m.UnlockedGrantIndexes = append(m.UnlockedGrantIndexes, v)
			} else if wireType == 2 {
				var packedLen int
				var _v uint64
				_v, iNdEx, err = protobuf_go_lite.DecodeVarint(dAtA, iNdEx)
				packedLen = int(_v)
				if err != nil {
					return err
				}
				if packedLen < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return protobuf_go_lite.ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UnlockedGrantIndexes) == 0 {
					m.UnlockedGrantIndexes = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					v, iNdEx, err = protobuf_go_lite.DecodeVarintUint32(dAtA, iNdEx)
					if err != nil {
						return err
					}
					m.UnlockedGrantIndexes = append(m.UnlockedGrantIndexes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockedGrantIndexes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := protobuf_go_lite.Skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return protobuf_go_lite.ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.unknownFields = append(m.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
