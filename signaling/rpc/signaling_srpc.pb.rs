// Code generated by protoc-gen-starpc-rust. DO NOT EDIT.
// protoc-gen-starpc-rust version: v0.46.1
// source: github.com/aperturerobotics/bifrost/signaling/rpc/signaling.proto

#[allow(unused_imports)]
use starpc::StreamExt;

/// Service ID for Signaling.
pub const SIGNALING_SERVICE_ID: &str = "signaling.rpc.Signaling";

/// Stream trait for Signaling.Listen.
#[starpc::async_trait]
pub trait SignalingListenStream: Send + Sync {
    /// Returns the context for this stream.
    fn context(&self) -> &starpc::Context;
    /// Receives a message from the stream.
    async fn recv(&self) -> starpc::Result<ListenResponse>;
    /// Closes the stream.
    async fn close(&self) -> starpc::Result<()>;
}

/// Stream trait for Signaling.Session.
#[starpc::async_trait]
pub trait SignalingSessionStream: Send + Sync {
    /// Returns the context for this stream.
    fn context(&self) -> &starpc::Context;
    /// Sends a message on the stream.
    async fn send(&self, msg: &SessionRequest) -> starpc::Result<()>;
    /// Receives a message from the stream.
    async fn recv(&self) -> starpc::Result<SessionResponse>;
    /// Closes the stream.
    async fn close(&self) -> starpc::Result<()>;
}

/// Client trait for Signaling.
#[starpc::async_trait]
pub trait SignalingClient: Send + Sync {
    /// Listen.
    async fn listen(&self, request: &ListenRequest) -> starpc::Result<Box<dyn SignalingListenStream>>;
    /// Session.
    async fn session(&self) -> starpc::Result<Box<dyn SignalingSessionStream>>;
}

/// Client implementation for Signaling.
pub struct SignalingClientImpl<C> {
    client: C,
}

impl<C: starpc::Client> SignalingClientImpl<C> {
    /// Creates a new client.
    pub fn new(client: C) -> Self {
        Self { client }
    }
}

#[starpc::async_trait]
impl<C: starpc::Client + 'static> SignalingClient for SignalingClientImpl<C> {
    async fn listen(&self, request: &ListenRequest) -> starpc::Result<Box<dyn SignalingListenStream>> {
        use starpc::ProstMessage;
        let data = request.encode_to_vec();
        let stream = self.client.new_stream("signaling.rpc.Signaling", "Listen", Some(&data)).await?;
        stream.close_send().await?;
        Ok(Box::new(SignalingListenStreamImpl { stream }))
    }
    async fn session(&self) -> starpc::Result<Box<dyn SignalingSessionStream>> {
        let stream = self.client.new_stream("signaling.rpc.Signaling", "Session", None).await?;
        Ok(Box::new(SignalingSessionStreamImpl { stream }))
    }
}

struct SignalingListenStreamImpl {
    stream: Box<dyn starpc::Stream>,
}

#[starpc::async_trait]
impl SignalingListenStream for SignalingListenStreamImpl {
    fn context(&self) -> &starpc::Context {
        self.stream.context()
    }
    async fn recv(&self) -> starpc::Result<ListenResponse> {
        self.stream.msg_recv().await
    }
    async fn close(&self) -> starpc::Result<()> {
        self.stream.close().await
    }
}

struct SignalingSessionStreamImpl {
    stream: Box<dyn starpc::Stream>,
}

#[starpc::async_trait]
impl SignalingSessionStream for SignalingSessionStreamImpl {
    fn context(&self) -> &starpc::Context {
        self.stream.context()
    }
    async fn send(&self, msg: &SessionRequest) -> starpc::Result<()> {
        self.stream.msg_send(msg).await
    }
    async fn recv(&self) -> starpc::Result<SessionResponse> {
        self.stream.msg_recv().await
    }
    async fn close(&self) -> starpc::Result<()> {
        self.stream.close().await
    }
}

/// Server trait for Signaling.
#[starpc::async_trait]
pub trait SignalingServer: Send + Sync {
    /// Listen.
    async fn listen(&self, request: ListenRequest, stream: Box<dyn starpc::Stream>) -> starpc::Result<()>;
    /// Session.
    async fn session(&self, stream: Box<dyn starpc::Stream>) -> starpc::Result<()>;
}

const SIGNALING_METHOD_IDS: &[&str] = &[
    "Listen",
    "Session",
];

/// Handler for Signaling.
pub struct SignalingHandler<S: SignalingServer> {
    server: std::sync::Arc<S>,
}

impl<S: SignalingServer + 'static> SignalingHandler<S> {
    /// Creates a new handler wrapping the server implementation.
    pub fn new(server: S) -> Self {
        Self { server: std::sync::Arc::new(server) }
    }

    /// Creates a new handler with a shared server.
    pub fn with_arc(server: std::sync::Arc<S>) -> Self {
        Self { server }
    }
}

#[starpc::async_trait]
impl<S: SignalingServer + 'static> starpc::Invoker for SignalingHandler<S> {
    async fn invoke_method(
        &self,
        _service_id: &str,
        method_id: &str,
        stream: Box<dyn starpc::Stream>,
    ) -> (bool, starpc::Result<()>) {
        match method_id {
            "Listen" => {
                let request: ListenRequest = match stream.msg_recv().await {
                    Ok(r) => r,
                    Err(e) => return (true, Err(e)),
                };
                (true, self.server.listen(request, stream).await)
            }
            "Session" => {
                (true, self.server.session(stream).await)
            }
            _ => (false, Err(starpc::Error::Unimplemented)),
        }
    }
}

impl<S: SignalingServer + 'static> starpc::Handler for SignalingHandler<S> {
    fn service_id(&self) -> &'static str {
        "signaling.rpc.Signaling"
    }

    fn method_ids(&self) -> &'static [&'static str] {
        SIGNALING_METHOD_IDS
    }
}

