// @generated by protoc-gen-es-starpc none with parameter "target=ts,ts_nocheck=false"
// @generated from file github.com/aperturerobotics/bifrost/signaling/rpc/signaling.proto (package signaling.rpc, syntax proto3)
/* eslint-disable */

import {
  ListenRequest,
  ListenResponse,
  SessionRequest,
  SessionResponse,
} from './signaling_pb.js'
import { MethodKind } from '@bufbuild/protobuf'
import { Message } from '@aptre/protobuf-es-lite'
import {
  buildDecodeMessageTransform,
  buildEncodeMessageTransform,
  MessageStream,
  ProtoRpc,
} from 'starpc'

/**
 * Signaling is a service which allows peers to signal each other via a RPC server.
 *
 * @generated from service signaling.rpc.Signaling
 */
export const SignalingDefinition = {
  typeName: 'signaling.rpc.Signaling',
  methods: {
    /**
     * Listen waits for messages to be available in our inbox from remote peers.
     *
     * @generated from rpc signaling.rpc.Signaling.Listen
     */
    Listen: {
      name: 'Listen',
      I: ListenRequest,
      O: ListenResponse,
      kind: MethodKind.ServerStreaming,
    },
    /**
     * Session opens a signaling session to send and recv messages from a remote peer.
     *
     * @generated from rpc signaling.rpc.Signaling.Session
     */
    Session: {
      name: 'Session',
      I: SessionRequest,
      O: SessionResponse,
      kind: MethodKind.BiDiStreaming,
    },
  },
} as const

/**
 * Signaling is a service which allows peers to signal each other via a RPC server.
 *
 * @generated from service signaling.rpc.Signaling
 */
export interface Signaling {
  /**
   * Listen waits for messages to be available in our inbox from remote peers.
   *
   * @generated from rpc signaling.rpc.Signaling.Listen
   */
  Listen(
    request: Message<ListenRequest>,
    abortSignal?: AbortSignal,
  ): MessageStream<ListenResponse>

  /**
   * Session opens a signaling session to send and recv messages from a remote peer.
   *
   * @generated from rpc signaling.rpc.Signaling.Session
   */
  Session(
    request: MessageStream<SessionRequest>,
    abortSignal?: AbortSignal,
  ): MessageStream<SessionResponse>
}

export const SignalingServiceName = SignalingDefinition.typeName

export class SignalingClient implements Signaling {
  private readonly rpc: ProtoRpc
  private readonly service: string
  constructor(rpc: ProtoRpc, opts?: { service?: string }) {
    this.service = opts?.service || SignalingServiceName
    this.rpc = rpc
    this.Listen = this.Listen.bind(this)
    this.Session = this.Session.bind(this)
  }
  /**
   * Listen waits for messages to be available in our inbox from remote peers.
   *
   * @generated from rpc signaling.rpc.Signaling.Listen
   */
  Listen(
    request: Message<ListenRequest>,
    abortSignal?: AbortSignal,
  ): MessageStream<ListenResponse> {
    const requestMsg = ListenRequest.create(request)
    const result = this.rpc.serverStreamingRequest(
      this.service,
      SignalingDefinition.methods.Listen.name,
      ListenRequest.toBinary(requestMsg),
      abortSignal || undefined,
    )
    return buildDecodeMessageTransform(ListenResponse)(result)
  }

  /**
   * Session opens a signaling session to send and recv messages from a remote peer.
   *
   * @generated from rpc signaling.rpc.Signaling.Session
   */
  Session(
    request: MessageStream<SessionRequest>,
    abortSignal?: AbortSignal,
  ): MessageStream<SessionResponse> {
    const result = this.rpc.bidirectionalStreamingRequest(
      this.service,
      SignalingDefinition.methods.Session.name,
      buildEncodeMessageTransform(SessionRequest)(request),
      abortSignal || undefined,
    )
    return buildDecodeMessageTransform(SessionResponse)(result)
  }
}
