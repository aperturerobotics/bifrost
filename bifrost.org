#+TITLE: Bifrost
#+AUTHOR: Christian Stewart 
#+EMAIL: christian@aperturerobotics.com
#+DESCRIPTION: Overview of the bifrost router.

Bifrost is a multi-hop encrypted mesh networking router.

The Bifrost router wraps a libp2p host with peer tracking and multi-hop routing.

** TODO Design Overview

Terminology and overview:

 - A node is a process with one or more attached peers sharing transports.
 - Each node has a set of transports, which yield links to other nodes.
 - Each node has a router, which tracks connections to other nodes and attempts
   to build new connections based on historical data.
 - Peers can request streams to other peers seamlessly.
 - Usually, a single host process binds to the network transports while the rest
   communicate via a unix socket to the host controller as a relay.

Links or "route segments":

 - Represent a single hop of connectivity between nodes.
 - Each end has an associated transport, usually the same.
 - Capture perf stats such as bandwidth, latency (ping time) and packet loss.
 - Statistics are aggregated when building routes into route scores.
 - Transport-level trends of statistics are kept to make predictions for new
   connection performances.

Examples of "links" or "route segments" and their associated transports:

 - Local machine -> local machine (shm shared memory transport)
 - Localhost -> Localhost (TCP or uDP transport)
 - Localhost -> internet -> Remote Host (TCP/UDP transport)
 - Localhost -> browser (WebRTC / Websocket transport)
 - Local machine -> radio -> remote machine (XBee transport)

The router can optionally preempt a solicitation:

 - Router B catches route solicitation packet A -> B -> F?
 - Lookup to see if B -> F has been made before.
 - Find a proven route B -> C -> F -> G, return to A

Types of packets that can be sent over the gossip layer:

 - Routing: route solicitation messages.
 - Telemetry: transport / link statistics repeated along all relevant routes.
 - Identity: identity solicitation messages.

Inspiration / references:

 - https://www.open-mesh.org/projects/batman-adv/wiki/Multi-link-optimize

** Virtual networking / compatibility layer

There are several planned interfaces to the router:

 - **API**: Go API to interface directly with the libp2p router in-process.
 - **IPC/Shmem*: inter-process communication on the same host.
 - **VPN**: a tun interface over which IPV6-addressed packets are sent.
 - **SOCKS5**: socks proxy for secure meshed connections.

For now, in-process is the primary implementation.

*** VPN addressing

Make a network interface on the machine (TUN). Use `gopacket` to do on-demand
decoding of the destination address. Translate the TCP packet stages through to
the proxying layer.

*** Proxy addressing

Listen with a SOCKS5 proxy on a port. Use a public-key derived format for the
destination address.

** Routing

The primary goals of this project vs. other routers, such as babel:

 - Route in user-space. Particularly important for cross-platform/browser.
 - Accept only authenticated peers, and encrypt traffic in channels.
 - Build encrypted circuits with diverse routes, then multiplex streams.

The routing algorithm works like this:

 - Gossip probes through the connection graph building routes between peers.
 - Probes are kept in memory of the peers until their expiration time (on the
   order of seconds to minutes) and repeated to peers that have not yet seen the
   probe.
 - Circuits can have further probing restrictions, like avoiding different types
   of network partitions (entering a network pocket, for example).

The general rules are:

 - Never re-transmit a route probe to a peer that appears in the probe's
   existing path.
 - Drop incoming probes that already contain the local peer.

** Transports

Questions:

 - Is PacketConn a good enough interface to have them implement?
 - Is the transport reliable? (does it handle re-transmission)
 - Is the transport MTU-capped? (if so, what is the MTU?)
 - Is the transport secured, and if so, what is the remote identity?
 - Does the transport support multicast?
 - How can we establish unreliable streams, and send this data in-band?

Overview:

 - Add an additional header to the packet, maybe 1 byte, to indicate type.
 - Types: Unreliable (raw), KCP (kcp-wrapped packet)

** Code Stack Overview

Low to high level:

 - Application Traffic (P2P metadata, other streams)
 - Stream Transport (P2P Link Protocol, KCP)
 - Packet Transport (UDP/TCP/XBEE/...) (has MTU? reliable? expected bandwidth?)

Given any kind of input packet transport:

 - UDP (unreliable/unordered, insecure)
 - TCP (reliable/ordered, insecure)
 - TCP/TLS pre-authed (reliable/ordered, secure)
 - ONION/TOR (reliable/ordered, secure)
 - QUIC (reliable/ordered, secure)

Types of handshake / encryption we want to support:

 - TLS (Certificates / X.509 / CA Certs / RSA)
 - S2S (Station to Station)

Transport encryption is added in an onion-like layered way, example:

 - S2S negotiation
 - KCP Connection (reliable, no streams, insecure)
 - UDP Connection (unordered/unreliable insecure)

** Connection Negotiation and Packet Structure

*** Secret Negotation / Key Exchange

Between Alice (A) and Bob (B) over a unencrypted / unordered connection.

 1. A computes a random number $x$, and sends its peer ID as well as the
    exponential $g^x$ to B. If the peer ID of B is predicted and B's public key
    is known, A indicates the expected peer ID of B.
 3. B generates a random number $y$ and computes the exponential $g^y$.
 4. B computes the shared secret key $K=(g^x)^y$.
 5. Bob concats the exponentials $(g^y, g^x)$, signs them using private key $B$,
    and then encrypts the signature with $K$. B sends ciphertext along with
    exponential $g^y$ to A. Included in the ciphertext is Bs public key if
    message 1 does not contain the correct peer ID, and a flag to indicate if
    A's public key was known.
 6. A computes the shared key $K=(g^y)^x$.
 7. A decrypts and verifies B's signature using B's public key.
 8. A concatenates the exponential $(g^x, g^y)$, signs them using A's private
    key, then encrypts the signature with K. Additionally, the public key is
    included in the ciphertext if B indicated it was not known. A sends the
    ciphertext to B.
 9. B decrypts and verifies A's signature using A's public key.

This process is the [[https://en.wikipedia.org/wiki/Station-to-Station_protocol][S2S Protocol]] modified to include a lazy public-key exchange.

*** Inner Protocol Upgrade

All packets have an attached 1 byte header. The header
indicates what type of packet follows with four LSB bits, IDs go as follows:

| ID      | Packet Type                 |
|---------+-----------------------------|
| $0x00$  | Handshake                   |
| $0x01$  | Raw unencrypted unreliable  |
| $0x02$  | KCP+SMUX reliable encrypted |
| $>0x16$ | (Out of range)              |

The four MSBs are used for the "conversation ID," determined randomly by the 
initiator and used to indicate when a new session starts.

Raw packets are used to transfer in-band data with minimal encrypt/decrypt
overhead. This marks an important capability of transferring data end-to-end
encrypted, rather than point-to-point. This approach yields a significant
performance bonus.

The types of packets supported are exchanged in the initial handshake.

This header is encrypted with the shared secret, and an nonce 

*** KCP Streams with Smux

This KCP stream uses the shared secret yielded by the key exchange as the secret
for Salsa20 packet-level encryption. This scheme encrypts all data transferred.

[[https://github.com/xtaci/smux][Smux]] is layered on top of this stream to provide multiple channels of
communication. 

*** Secure Streams

The negotiated secure streaming scheme is used, and passed to the streams
abstraction layer in the form of an opaque interface.

Each stream is opened with a stream intent packet. The intent packet indicates
what kind of stream is intended, which is used to route the stream to the
appropriate packet handler.

** Multicast Coding

Could use available airtime to transmit to multiple peers at the same time.

If multicast is possible, can send identical packet to multiple peers. Can also
transmit data down two branches in a route fork using huffman coding.

** Code Design

Objectives:

 - Extremely low CPU/Memory usage for embedded.
 - Durable to DOS attacks.
 - Modular to allow code re-use in the browser.

We introduce a "context tree" of state machines / controllers:

- NodeController: tracks configured sub-controllers.
- LinkController: tracks + controls active / sleeping links and updates the
  graph database.
- Sub-controller types:
  - TransportFactory: automatically generates Transport instances and runs them
    as sub-controllers.
    - Transport: a listener / dialer running on a particular interface.
      - Link: an instance of an open / known (and later, lost / closed) connection
        to a peer.

Each "controller" has a context, that when canceled, also cancels the context of
all sub-controllers. Each controller has a execute goroutine, which handles
runtime logic for the particular component of the system.

Link has the following properties:

 - Identification: is the connection identified, do we expect a specific peer?
 - Encryption: is the connection already encrypted to the peer?
 - Reliability: is the connection ordered (TCP) or unreliable (UDP/XBee).

It is up to the transport / link to chose which handshake and encryption type to
use.

A Link object is an established and running link. It:

 - Emits state to observers.
 - Returns a LinkInfo object with information about the link.
 - Embeds a packet into the link info with re-dial information.

*** E2E: Initialization of node and transports

Node needs to be aware of:

 + List of active root transport factories (create transports or other factories)
 + List of active transports (all transports created by all factories)
 + List of active links (all links created by all transports)

Therefore:

 - Node is constructed with a private key.
 - Transport factories are attached with AddTransportFactory.
 - Transport factories produce transports that are added to the node automatically.
 - Other transports can be attached with AddTransport.
 - A "config" transport factory is attached with a given configuration source
   (JSON file for example or CLI) and this factory creates / shuts down transports
 - Shutting down a node closes all transport factories Execute() contexts

*** E2E: Incoming connection

 - UDP transport binds to a local address and port.
 - Receives a establishing packet from a given remote address and port.
 - New session is created, bind to a new random port.

** Browser Code Re-use

The majority of the code should be re-usable. WebSocket + WebRTC transport can
be implemented with JS bindings, while other transports will be build-flagged to
not be included. Other than networking, bifrost uses no OS-specific code that
would not be usable in JS via GopherJS or WebAssembly.

** Issues

Potential issue discussion.

*** Re-encryption latency

At the moment this design dictates:

 - Xmit via route A -> B -> C -> D
 - Packet is crafted on A, encrypted to D.
 - Encrypted packet is transmitted A->B.
 - Both the metadata AND the packet decrypted on B.
 - Both metadata And the packet re-encrypted B -> C.
 - Encrypted packet is transmitted B -> C.
 - Etc ...

There is an unnecessary encrypt/decrypt step here. A possible solution might be:

 - Encrypt the body of the packet to the destination (end-to-end).
 - Sign / encrypt the header of the packet only.
 - Transmit the header, then the body. Do not decrypt / encrypt the body.

This requires:

 - Packet-level transports.
 - Ability to flag a packet as O_ENCRYPT or not.

An option here might be to just not encrypt at the transport level, I think
this makes the most sense.

Can prefix a packet with a header indicating if it is encrypted or not.

Use a unique ID for the connection to reference the block of unencrypted data
as an encrypted inner packet getting transported via a route.

*** Transport security / KCP

 - How can we maintain protocol modularity?
 - How to negotiate the KCP connection?

*** Connection sleeping / virtual network graph

Sometimes we may want to "sleep" links between nodes, for example:

 - Make a internet connection between two inter-planetary nodes.
 - Notice that the average ping time is high, packet loss high.
 - Prioritize a faster link. Connection is idle, and the link closes.
 - Close the link, mark it as "asleep" in the link database.
 - When attempting to use the link in the future, can wake it by re-dialing.

When booting up, nodes will always start out with local links as asleep. This
will allow a natural re-dial mechanism where the better links are attempted to
be re-established first.

** Further research

Ideas from ethereum:

 - multiple authenticated connectivity modes (ECDH+ECDHE, AES128)
 - authenticated discovery (ECDSA)
 - connection framing
 - peer reputation model

