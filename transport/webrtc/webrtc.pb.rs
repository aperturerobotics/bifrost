// @generated
// This file is @generated by prost-build.
/// Config is the configuration for the WebRTC Signal RPC transport.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Config {
    /// SignalingId is the signaling channel identifier.
    /// Cannot be empty.
    #[prost(string, tag="1")]
    pub signaling_id: ::prost::alloc::string::String,
    /// TransportPeerId sets the peer ID to attach the transport to.
    /// If unset, attaches to any running peer with a private key.
    /// Must match the transport peer ID of the signaling transport.
    #[prost(string, tag="2")]
    pub transport_peer_id: ::prost::alloc::string::String,
    /// TransportType overrides the transport type id for dial addresses.
    /// Defaults to "webrtc"
    /// Configures the scheme for addr matching to this transport.
    /// E.x.: webrtc://
    #[prost(string, tag="3")]
    pub transport_type: ::prost::alloc::string::String,
    /// Quic contains the quic protocol options.
    ///
    /// The WebRTC transport always disables FEC and several other UDP-centric
    /// features which are unnecessary due to the "reliable" nature of WebRTC.
    #[prost(message, optional, tag="4")]
    pub quic: ::core::option::Option<super::transport::quic::Opts>,
    /// WebRtc contains the WebRTC protocol options.
    #[prost(message, optional, tag="5")]
    pub web_rtc: ::core::option::Option<WebRtcConfig>,
    /// Backoff is the backoff config for connecting to a PeerConnection.
    /// If unset, defaults to reasonable defaults.
    #[prost(message, optional, tag="6")]
    pub backoff: ::core::option::Option<super::backoff::Backoff>,
    /// Dialers maps peer IDs to dialers.
    /// This allows mapping which peer ID should be dialed via this transport.
    #[prost(map="string, message", tag="7")]
    pub dialers: ::std::collections::HashMap<::prost::alloc::string::String, super::dialer::DialerOpts>,
    /// AllPeers tells the transport to attempt to negotiate a WebRTC session with
    /// any peer, even those not listed in the Dialers map.
    #[prost(bool, tag="8")]
    pub all_peers: bool,
    /// DisableListen disables listening for incoming Links.
    /// If set, we will only dial out, not accept incoming links.
    #[prost(bool, tag="9")]
    pub disable_listen: bool,
    /// BlockPeers is a list of peer ids that will not be contacted via this transport.
    #[prost(string, repeated, tag="10")]
    pub block_peers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Verbose enables very verbose logging.
    #[prost(bool, tag="11")]
    pub verbose: bool,
}
/// WebRtcConfig configures the WebRTC PeerConnection.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WebRtcConfig {
    /// IceServers contains the list of ICE servers to use.
    #[prost(message, repeated, tag="1")]
    pub ice_servers: ::prost::alloc::vec::Vec<IceServerConfig>,
    /// IceTransportPolicy defines the policy for permitted ICE candidates.
    /// Optional.
    #[prost(enumeration="IceTransportPolicy", tag="2")]
    pub ice_transport_policy: i32,
    /// IceCandidatePoolSize defines the size of the prefetched ICE pool.
    /// Optional.
    #[prost(uint32, tag="3")]
    pub ice_candidate_pool_size: u32,
}
/// IceServer is a WebRTC ICE server config.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IceServerConfig {
    /// Urls is the list of URLs for the ICE server.
    ///
    /// Format: stun:{url} or turn:{url} or turns:{url}?transport=tcp
    /// Examples:
    /// - stun:stun.l.google.com:19302
    /// - stun:stun.stunprotocol.org:3478
    /// - turns:google.de?transport=tcp
    #[prost(string, repeated, tag="1")]
    pub urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Username is the username for the ICE server.
    #[prost(string, tag="2")]
    pub username: ::prost::alloc::string::String,
    /// Credential contains the ice server credential, if any.
    #[prost(oneof="ice_server_config::Credential", tags="3, 4")]
    pub credential: ::core::option::Option<ice_server_config::Credential>,
}
/// Nested message and enum types in `IceServerConfig`.
pub mod ice_server_config {
    /// OauthCredential is an OAuth credential information for the ICE server.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct OauthCredential {
        /// MacKey is a base64-url format.
        #[prost(string, tag="1")]
        pub mac_key: ::prost::alloc::string::String,
        /// AccessToken is the access token in base64-encoded format.
        #[prost(string, tag="2")]
        pub access_token: ::prost::alloc::string::String,
    }
    /// Credential contains the ice server credential, if any.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Credential {
        /// Password contains the ICE server password.
        #[prost(string, tag="3")]
        Password(::prost::alloc::string::String),
        /// Oauth contains an OAuth credential.
        #[prost(message, tag="4")]
        Oauth(OauthCredential),
    }
}
/// WebRtcSignal is a WebRTC Signaling message sent via the Signaling channel.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WebRtcSignal {
    /// Body is the body of the message.
    #[prost(oneof="web_rtc_signal::Body", tags="1, 2, 3")]
    pub body: ::core::option::Option<web_rtc_signal::Body>,
}
/// Nested message and enum types in `WebRtcSignal`.
pub mod web_rtc_signal {
    /// Body is the body of the message.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Body {
        /// RequestOffer requests a new offer from the offerer with the local session seqno.
        /// Incremented when negotiation is needed (something changes about the session).
        #[prost(uint64, tag="1")]
        RequestOffer(u64),
        /// Sdp contains the sdp offer or answer.
        #[prost(message, tag="2")]
        Sdp(super::WebRtcSdp),
        /// Ice contains an ICE candidate.
        #[prost(message, tag="3")]
        Ice(super::WebRtcIce),
    }
}
/// WebRtcSdp contains the SDP offer or answer.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WebRtcSdp {
    /// TxSeqno is the sequence number of the transmitting peer.
    /// The receiver should update the local seqno to match.
    #[prost(uint64, tag="1")]
    pub tx_seqno: u64,
    /// SdpType is the string encoded type of the sdp.
    /// Examples: "offer" "answer"
    #[prost(string, tag="2")]
    pub sdp_type: ::prost::alloc::string::String,
    /// Sdp contains the WebRTC session description.
    #[prost(string, tag="3")]
    pub sdp: ::prost::alloc::string::String,
}
/// WebRtcIce contains an ICE candidate.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WebRtcIce {
    /// Candidate contains the JSON-encoded ICE candidate.
    #[prost(string, tag="1")]
    pub candidate: ::prost::alloc::string::String,
}
/// IceTransportPolicy contains the set of allowed ICE transport policies.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IceTransportPolicy {
    /// IceTransportPolicy_ALL allows any kind of ICE candidate.
    All = 0,
    /// IceTransportPolicy_RELAY allows only media relay candidates (TURN).
    Relay = 1,
}
impl IceTransportPolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::All => "IceTransportPolicy_ALL",
            Self::Relay => "IceTransportPolicy_RELAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "IceTransportPolicy_ALL" => Some(Self::All),
            "IceTransportPolicy_RELAY" => Some(Self::Relay),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
