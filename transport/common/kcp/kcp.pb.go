// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/aperturerobotics/bifrost/transport/common/kcp/kcp.proto

package kcp

import (
	fmt "fmt"
	blockcompress "github.com/aperturerobotics/bifrost/util/blockcompress"
	blockcrypt "github.com/aperturerobotics/bifrost/util/blockcrypt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// KCPMode is the mode to set KCP to.
type KCPMode int32

const (
	// KCPMode_UNKNOWN defaults to normal mode.
	KCPMode_KCPMode_UNKNOWN KCPMode = 0
	// KCPMode_NORMAL is the normal mode.
	// NoDelay = 0
	// Interval = 40
	// Resend = 2
	// NoCongestion = 1
	KCPMode_KCPMode_NORMAL KCPMode = 1
	// KCPMode_FAST is the "fast" mode.
	// NoDelay = 0
	// Interval = 30
	// Resend = 2
	// NoCongestion = 1
	KCPMode_KCPMode_FAST KCPMode = 2
	// KCPMode_FAST2 is the "fast2" mode.
	// NoDelay = 1
	// Interval = 20
	// Resend = 2
	// NoCongestion = 1
	KCPMode_KCPMode_FAST2 KCPMode = 3
	// KCPMode_FAST3 is the "fast3" mode.
	// NoDelay = 1
	// Interval = 10
	// Resend = 2
	// NoCongestion = 1
	KCPMode_KCPMode_FAST3 KCPMode = 4
	// KCPMode_SLOW1 is the slow 1 mode.
	// NoDelay = 0
	// Interval = 100
	// Resend = 0
	// NoCongestion = 0
	KCPMode_KCPMode_SLOW1 KCPMode = 5
)

var KCPMode_name = map[int32]string{
	0: "KCPMode_UNKNOWN",
	1: "KCPMode_NORMAL",
	2: "KCPMode_FAST",
	3: "KCPMode_FAST2",
	4: "KCPMode_FAST3",
	5: "KCPMode_SLOW1",
}

var KCPMode_value = map[string]int32{
	"KCPMode_UNKNOWN": 0,
	"KCPMode_NORMAL":  1,
	"KCPMode_FAST":    2,
	"KCPMode_FAST2":   3,
	"KCPMode_FAST3":   4,
	"KCPMode_SLOW1":   5,
}

func (x KCPMode) String() string {
	return proto.EnumName(KCPMode_name, int32(x))
}

func (KCPMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b03fd2367a69a46, []int{0}
}

// StreamMuxer sets the type of stream muxer to use.
type StreamMuxer int32

const (
	// StreamMuxer_UNKNOWN defaults to StreamMuxer_XTACI_SMUX
	StreamMuxer_StreamMuxer_UNKNOWN StreamMuxer = 0
	// StreamMuxer_XTACI_SMUX is the xtaci/smux muxer.
	StreamMuxer_StreamMuxer_XTACI_SMUX StreamMuxer = 1
	// StreamMuxer_YAMUX is the yamux muxer.
	StreamMuxer_StreamMuxer_YAMUX StreamMuxer = 2
)

var StreamMuxer_name = map[int32]string{
	0: "StreamMuxer_UNKNOWN",
	1: "StreamMuxer_XTACI_SMUX",
	2: "StreamMuxer_YAMUX",
}

var StreamMuxer_value = map[string]int32{
	"StreamMuxer_UNKNOWN":    0,
	"StreamMuxer_XTACI_SMUX": 1,
	"StreamMuxer_YAMUX":      2,
}

func (x StreamMuxer) String() string {
	return proto.EnumName(StreamMuxer_name, int32(x))
}

func (StreamMuxer) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b03fd2367a69a46, []int{1}
}

// Opts are extra options for the packet conn.
type Opts struct {
	// DataShards are the number of FEC data shards to use. By adding t check
	// symbols to the data, a Reed–Solomon code can detect any combination of up
	// to t erroneous symbols, or correct up to ⌊t/2⌋ symbols. As an erasure code,
	// it can correct up to t known erasures, or it can detect and correct
	// combinations of errors and erasures. Furthermore, Reed–Solomon codes are
	// suitable as multiple-burst bit-error correcting codes, since a sequence of
	// b + 1 consecutive bit errors can affect at most two symbols of size b. The
	// choice of t is up to the designer of the code, and may be selected within
	// wide limits. Maximum is 256.
	// Recommended: 10
	// If zero, FEC is disabled.
	DataShards uint32 `protobuf:"varint,1,opt,name=data_shards,json=dataShards,proto3" json:"data_shards,omitempty"`
	// ParityShards are the number of FEC parity shards to use.
	// Recommended: 3
	ParityShards uint32 `protobuf:"varint,2,opt,name=parity_shards,json=parityShards,proto3" json:"parity_shards,omitempty"`
	// Mtu is the maximum transmission unit to use.
	// Defaults to 1350 (UDP safe packet size).
	Mtu uint32 `protobuf:"varint,3,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// KcpMode is the KCP mode.
	KcpMode KCPMode `protobuf:"varint,4,opt,name=kcp_mode,json=kcpMode,proto3,enum=kcp.KCPMode" json:"kcp_mode,omitempty"`
	// BlockCrypt is the block crypto to use.
	// Defaults to AES256.
	// Uses the handshake-negotiated session key.
	BlockCrypt blockcrypt.BlockCrypt `protobuf:"varint,5,opt,name=block_crypt,json=blockCrypt,proto3,enum=blockcrypt.BlockCrypt" json:"block_crypt,omitempty"`
	// BlockCompress is the block compression to use.
	BlockCompress blockcompress.BlockCompress `protobuf:"varint,6,opt,name=block_compress,json=blockCompress,proto3,enum=blockcompress.BlockCompress" json:"block_compress,omitempty"`
	// StreamMuxer is the stream muxer to use.
	// Defaults to smux.
	StreamMuxer          StreamMuxer `protobuf:"varint,7,opt,name=stream_muxer,json=streamMuxer,proto3,enum=kcp.StreamMuxer" json:"stream_muxer,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Opts) Reset()         { *m = Opts{} }
func (m *Opts) String() string { return proto.CompactTextString(m) }
func (*Opts) ProtoMessage()    {}
func (*Opts) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b03fd2367a69a46, []int{0}
}

func (m *Opts) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Opts.Unmarshal(m, b)
}
func (m *Opts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Opts.Marshal(b, m, deterministic)
}
func (m *Opts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Opts.Merge(m, src)
}
func (m *Opts) XXX_Size() int {
	return xxx_messageInfo_Opts.Size(m)
}
func (m *Opts) XXX_DiscardUnknown() {
	xxx_messageInfo_Opts.DiscardUnknown(m)
}

var xxx_messageInfo_Opts proto.InternalMessageInfo

func (m *Opts) GetDataShards() uint32 {
	if m != nil {
		return m.DataShards
	}
	return 0
}

func (m *Opts) GetParityShards() uint32 {
	if m != nil {
		return m.ParityShards
	}
	return 0
}

func (m *Opts) GetMtu() uint32 {
	if m != nil {
		return m.Mtu
	}
	return 0
}

func (m *Opts) GetKcpMode() KCPMode {
	if m != nil {
		return m.KcpMode
	}
	return KCPMode_KCPMode_UNKNOWN
}

func (m *Opts) GetBlockCrypt() blockcrypt.BlockCrypt {
	if m != nil {
		return m.BlockCrypt
	}
	return blockcrypt.BlockCrypt_BlockCrypt_UNKNOWN
}

func (m *Opts) GetBlockCompress() blockcompress.BlockCompress {
	if m != nil {
		return m.BlockCompress
	}
	return blockcompress.BlockCompress_BlockCompress_NONE
}

func (m *Opts) GetStreamMuxer() StreamMuxer {
	if m != nil {
		return m.StreamMuxer
	}
	return StreamMuxer_StreamMuxer_UNKNOWN
}

func init() {
	proto.RegisterEnum("kcp.KCPMode", KCPMode_name, KCPMode_value)
	proto.RegisterEnum("kcp.StreamMuxer", StreamMuxer_name, StreamMuxer_value)
	proto.RegisterType((*Opts)(nil), "kcp.Opts")
}

func init() {
	proto.RegisterFile("github.com/aperturerobotics/bifrost/transport/common/kcp/kcp.proto", fileDescriptor_3b03fd2367a69a46)
}

var fileDescriptor_3b03fd2367a69a46 = []byte{
	// 419 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0x41, 0x6f, 0xd4, 0x30,
	0x10, 0x85, 0xc9, 0xee, 0xb6, 0x8b, 0x66, 0x37, 0x8b, 0xeb, 0x8a, 0x12, 0xad, 0x90, 0xa8, 0xe0,
	0x40, 0xd5, 0x43, 0x22, 0xba, 0x07, 0xce, 0x69, 0x10, 0x12, 0xb4, 0x49, 0x50, 0xd2, 0xaa, 0xed,
	0x29, 0x4a, 0x9c, 0x40, 0xa3, 0xd4, 0xb5, 0x65, 0x3b, 0x12, 0x3d, 0xf0, 0xc7, 0xf8, 0x75, 0xc8,
	0x4e, 0x16, 0x5c, 0x4e, 0x70, 0x88, 0xf4, 0xe6, 0x9b, 0x99, 0xa7, 0x79, 0x91, 0xe1, 0xf4, 0x5b,
	0xab, 0x6e, 0xfb, 0xca, 0x27, 0x8c, 0x06, 0x25, 0x6f, 0x84, 0xea, 0x45, 0x23, 0x58, 0xc5, 0x54,
	0x4b, 0x64, 0x50, 0xb5, 0x5f, 0x05, 0x93, 0x2a, 0x50, 0xa2, 0xbc, 0x97, 0x9c, 0x09, 0x15, 0x10,
	0x46, 0x29, 0xbb, 0x0f, 0x3a, 0xc2, 0xf5, 0xe7, 0x73, 0xc1, 0x14, 0xc3, 0xd3, 0x8e, 0xf0, 0xf5,
	0x87, 0x7f, 0x31, 0xea, 0x55, 0x7b, 0x17, 0x54, 0x77, 0x8c, 0x74, 0x44, 0x3c, 0x70, 0x65, 0xc9,
	0xc1, 0x6a, 0xfd, 0xf9, 0x3f, 0x5d, 0x18, 0xe5, 0xa2, 0x91, 0xf2, 0x71, 0x35, 0x78, 0xbd, 0xfe,
	0x39, 0x81, 0x59, 0xca, 0x95, 0xc4, 0xaf, 0x60, 0x51, 0x97, 0xaa, 0x2c, 0xe4, 0x6d, 0x29, 0x6a,
	0xe9, 0x39, 0x87, 0xce, 0x91, 0x9b, 0x81, 0x46, 0xb9, 0x21, 0xf8, 0x0d, 0xb8, 0xbc, 0x14, 0xad,
	0x7a, 0xd8, 0x8e, 0x4c, 0xcc, 0xc8, 0x72, 0x80, 0xe3, 0x10, 0x82, 0x29, 0x55, 0xbd, 0x37, 0x35,
	0x2d, 0x2d, 0xf1, 0x5b, 0x78, 0xda, 0x11, 0x5e, 0x50, 0x56, 0x37, 0xde, 0xec, 0xd0, 0x39, 0x5a,
	0x9d, 0x2c, 0x7d, 0xfd, 0x57, 0xce, 0xa2, 0x2f, 0x31, 0xab, 0x9b, 0x6c, 0xde, 0x11, 0xae, 0x05,
	0x7e, 0x0f, 0x0b, 0x73, 0x60, 0x61, 0xa2, 0x7a, 0x3b, 0x66, 0xf6, 0xc0, 0xb7, 0xd2, 0x9f, 0x6a,
	0x19, 0x69, 0x99, 0x41, 0xf5, 0x5b, 0xe3, 0x08, 0x56, 0xe3, 0xe2, 0x18, 0xcd, 0xdb, 0x35, 0xbb,
	0x2f, 0xfd, 0xc7, 0x81, 0x87, 0xf5, 0xb1, 0xca, 0xdc, 0xca, 0x2e, 0xf1, 0x06, 0x96, 0x52, 0x89,
	0xa6, 0xa4, 0x05, 0xed, 0xbf, 0x37, 0xc2, 0x9b, 0x1b, 0x0b, 0x64, 0x4e, 0xcd, 0x4d, 0x23, 0xd6,
	0x3c, 0x5b, 0xc8, 0x3f, 0xc5, 0xf1, 0x0f, 0x98, 0x8f, 0x31, 0xf0, 0x3e, 0x3c, 0x1b, 0x65, 0x71,
	0x99, 0x9c, 0x25, 0xe9, 0x55, 0x82, 0x9e, 0x60, 0x0c, 0xab, 0x2d, 0x4c, 0xd2, 0x2c, 0x0e, 0xcf,
	0x91, 0x83, 0x11, 0x2c, 0xb7, 0xec, 0x63, 0x98, 0x5f, 0xa0, 0x09, 0xde, 0x03, 0xd7, 0x26, 0x27,
	0x68, 0xfa, 0x37, 0xda, 0xa0, 0x99, 0x8d, 0xf2, 0xf3, 0xf4, 0xea, 0x1d, 0xda, 0x39, 0xbe, 0x81,
	0x85, 0x75, 0x1a, 0x7e, 0x01, 0xfb, 0x56, 0x69, 0x9d, 0xb1, 0x86, 0x03, 0xbb, 0x71, 0x7d, 0x11,
	0x46, 0x9f, 0x8a, 0x3c, 0xbe, 0xbc, 0x46, 0x0e, 0x7e, 0x0e, 0x7b, 0x76, 0xef, 0x26, 0xd4, 0x78,
	0x52, 0xed, 0x9a, 0xd7, 0xb1, 0xf9, 0x15, 0x00, 0x00, 0xff, 0xff, 0xc9, 0x0b, 0x42, 0x3a, 0xfa,
	0x02, 0x00, 0x00,
}
